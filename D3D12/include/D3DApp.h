#ifndef D3DAPP_H 
#define D3DAPP_H


#ifndef EXPORTTING
#define DECLSPEC __declspec(dllimport)
#else
#define DECLSPEC __declspec(dllexport)
#endif // EXPORTTING

#include <d3d12.h>
#include <d3dx12.h>
#include <wrl.h>
#include <iostream>

#include "D3D12Util.h"
#include "minwindef.h"
#include "dxgi.h"
#include "dxgi1_4.h"

class D3DApp {
private:
	/// 工厂对象
	Microsoft::WRL::ComPtr <IDXGIFactory4> dxgi_factory_;
	/// 交换链对象
	Microsoft::WRL::ComPtr <IDXGISwapChain> swap_chain_;
	/// 硬件对象
	Microsoft::WRL::ComPtr <ID3D12Device> d3d_device_;
	/// CPU和GPU之间的屏障对象
	Microsoft::WRL::ComPtr <ID3D12Fence> fence_;
	/// 命令队列
	Microsoft::WRL::ComPtr <ID3D12CommandQueue> command_queue_;
	/// 命令列表
	Microsoft::WRL::ComPtr <ID3D12GraphicsCommandList> direct_list_;
	/// 命令分配器
	Microsoft::WRL::ComPtr <ID3D12CommandAllocator> direct_allocator_;
	/// rtv堆
	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> rtv_heap_;
	/// dsv堆
	Microsoft::WRL::ComPtr <ID3D12DescriptorHeap> dsv_heap_;
	/// 描述符的大小
	/// RenderTargetView 只写的渲染对象
	UINT rtv_size_{};
	/// DepthStencilView 只写的深度缓冲对象
	UINT dsv_size_{};
	/// UnorderedAccessView ConstantBufferView ShaderResourceView 这三个大小是一致的
	UINT cbv_srv_uav_size_{};
	/// 控制抗锯齿
	bool MSAA4x_state_ = false;
private:
	/**
	 * 初始化D3D12.
	 * 
	 * \return 是否初始化成功
	 */
	bool InitializeD3D();
	/**
	 * @brief 创建命令队列，命令列表和命令分配器.
	 */
	void CreateCommandObjects();
	/**
	 * @brief 创建交换链.
	 * 
	 */
	void CreateSwapChain();
	/**
	 * @brief 创建描述符堆.
	 * 
	 */
	void CreateDescriptorHeaps();
	D3D12_CPU_DESCRIPTOR_HANDLE CurrentBackBufferDesc()const;
	D3D12_CPU_DESCRIPTOR_HANDLE DepthStencilDesc()const;
protected:
	/// 应用程序的实例句柄
	HINSTANCE instance_ = nullptr;
	/// 主窗口的实例句柄
	HWND handle_mainWnd_ = nullptr;
	/// 使用几个缓冲区
	static const int swap_chain_buffer_cnt_ = 2;
	/// 当前是哪个缓冲区（以便于我们知道现在该绘制哪一个）
	int current_back_buffer_idx_ = 0;
	UINT client_width_ = 800;
	UINT client_height_ = 600;
	/// 后台缓冲区的显示格式
	DXGI_FORMAT back_buffer_format_ = DXGI_FORMAT_R8G8B8A8_UNORM;
public:
	D3DApp(HINSTANCE);
	bool initialize();
	~D3DApp();
};



#endif
